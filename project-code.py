import time
import math
import sys
import random
import os
from threading import Event

sys.setrecursionlimit(10000)

class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def print_algorithm_description():
    """–í–∏–≤–æ–¥–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω–∏–π –æ–ø–∏—Å –∞–ª–≥–æ—Ä–∏—Ç–º—É LCA"""
    print(f"{Colors.HEADER}{Colors.BOLD}=== –ê–õ–ì–û–†–ò–¢–ú LOWEST COMMON ANCESTOR (LCA) ==={Colors.ENDC}")
    print(f"{Colors.OKBLUE}üìö –û–ü–ò–° –ê–õ–ì–û–†–ò–¢–ú–£:{Colors.ENDC}")
    print("""
LCA (Lowest Common Ancestor) - –Ω–∞–π–Ω–∏–∂—á–∏–π —Å–ø—ñ–ª—å–Ω–∏–π –ø—Ä–µ–¥–æ–∫ –¥–≤–æ—Ö –≤–µ—Ä—à–∏–Ω —É –¥–µ—Ä–µ–≤—ñ.

üîç –ú–ï–¢–û–î Binary Lifting:
1Ô∏è‚É£  –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥: —Å—Ç–≤–æ—Ä—é—î–º–æ —Ç–∞–±–ª–∏—Ü—é –ø—Ä–µ–¥–∫—ñ–≤ –¥–ª—è –∫–æ–∂–Ω–æ—ó –≤–µ—Ä—à–∏–Ω–∏
2Ô∏è‚É£  –í–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è –≥–ª–∏–±–∏–Ω: –ø—ñ–¥–Ω—ñ–º–∞—î–º–æ –≥–ª–∏–±—à—É –≤–µ—Ä—à–∏–Ω—É –¥–æ —Ä—ñ–≤–Ω—è –º–µ–Ω—à–æ—ó
3Ô∏è‚É£  –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–π –ø—ñ–¥–π–æ–º: –ø—ñ–¥–Ω—ñ–º–∞—î–º–æ –æ–±–∏–¥–≤—ñ –≤–µ—Ä—à–∏–Ω–∏ –¥–æ —Å–ø—ñ–ª—å–Ω–æ–≥–æ –ø—Ä–µ–¥–∫–∞

‚ö° –°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å:
   ‚Ä¢ –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥: O(n log n)
   ‚Ä¢ –ó–∞–ø–∏—Ç LCA: O(log n)
   ‚Ä¢ –ü–∞–º'—è—Ç—å: O(n log n)

üéØ –ó–ê–°–¢–û–°–£–í–ê–ù–ù–Ø: –≥–µ–Ω–µ–∞–ª–æ–≥—ñ—á–Ω—ñ –¥–µ—Ä–µ–≤–∞, —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–∞–Ω–∏—Ö, –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –Ω–∞ –≥—Ä–∞—Ñ–∞—Ö
    """)
    input(f"{Colors.WARNING}–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å Enter –¥–ª—è –ø—Ä–æ–¥–æ–≤–∂–µ–Ω–Ω—è...{Colors.ENDC}")

def print_interface_description():
    """–í–∏–≤–æ–¥–∏—Ç—å –æ–ø–∏—Å —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É –ø—Ä–æ–≥—Ä–∞–º–∏"""
    print(f"{Colors.HEADER}{Colors.BOLD}=== –û–ü–ò–° –Ü–ù–¢–ï–†–§–ï–ô–°–£ ==={Colors.ENDC}")
    print(f"{Colors.OKBLUE}üéÆ –ö–ï–†–£–í–ê–ù–ù–Ø –ü–†–û–ì–†–ê–ú–û–Æ:{Colors.ENDC}")
    print("""
üìã –ì–û–õ–û–í–ù–ï –ú–ï–ù–Æ:
   ‚Ä¢ –û–±–µ—Ä—ñ—Ç—å –≥–æ—Ç–æ–≤–∏–π –ø—Ä–∏–∫–ª–∞–¥ –¥–µ—Ä–µ–≤–∞
   ‚Ä¢ –°—Ç–≤–æ—Ä—ñ—Ç—å –≤–ª–∞—Å–Ω–µ –¥–µ—Ä–µ–≤–æ
   ‚Ä¢ –ü–µ—Ä–µ–≥–ª—è–¥–∞–π—Ç–µ ASCII-–≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é

üîß –†–ï–ñ–ò–ú–ò –í–ò–ö–û–ù–ê–ù–ù–Ø:
   1Ô∏è‚É£  –†—É—á–Ω–∏–π —Ä–µ–∂–∏–º - –Ω–∞—Ç–∏—Å–∫–∞–π—Ç–µ Enter –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –∫—Ä–æ–∫—É
   2Ô∏è‚É£  –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–µ–∂–∏–º - –≤—Å—Ç–∞–Ω–æ–≤—ñ—Ç—å —à–≤–∏–¥–∫—ñ—Å—Ç—å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
   3Ô∏è‚É£  –ó–º—ñ—à–∞–Ω–∏–π —Ä–µ–∂–∏–º - –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –ø–∞—É–∑–∏ –≤ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–º—É —Ä–µ–∂–∏–º—ñ

‚å®Ô∏è  –ö–û–ú–ê–ù–î–ò –ü–Ü–î –ß–ê–° –í–ò–ö–û–ù–ê–ù–ù–Ø:
   ‚Ä¢ Enter - –Ω–∞—Å—Ç—É–ø–Ω–∏–π –∫—Ä–æ–∫ (—Ä—É—á–Ω–∏–π —Ä–µ–∂–∏–º)
   ‚Ä¢ 'p' + Enter - –ø–∞—É–∑–∞/–ø—Ä–æ–¥–æ–≤–∂–µ–Ω–Ω—è (–∞–≤—Ç–æ —Ä–µ–∂–∏–º)
   ‚Ä¢ 'q' + Enter - –≤–∏—Ö—ñ–¥ –∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∑–∞–ø–∏—Ç—É

üé® –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–Ø:
   ‚Ä¢ –ó–µ–ª–µ–Ω–∏–π –∫–æ–ª—ñ—Ä - –ø–æ—Ç–æ—á–Ω—ñ –∞–∫—Ç–∏–≤–Ω—ñ –≤–µ—Ä—à–∏–Ω–∏
   ‚Ä¢ –ñ–æ–≤—Ç–∏–π –∫–æ–ª—ñ—Ä - –≤–∞–∂–ª–∏–≤–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è
   ‚Ä¢ –°–∏–Ω—ñ–π –∫–æ–ª—ñ—Ä - —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–µ—Ä–µ–≤–∞
    """)
    input(f"{Colors.WARNING}–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å Enter –¥–ª—è –ø—Ä–æ–¥–æ–≤–∂–µ–Ω–Ω—è...{Colors.ENDC}")

# ---------------------- –î–µ–º–æ –ø—Ä–∏–∫–ª–∞–¥–∏ ----------------------

def get_demo_examples():
    random.seed(42)
    n = 127
    edges = []
    parents = [0]

    for i in range(1, n):
        parent = random.choice(parents[-20:])
        edges.append((parent, i))
        parents.append(i)

    return {
        "–ú–∞–ª–µ –¥–µ—Ä–µ–≤–æ (6 –≤–µ—Ä—à–∏–Ω)": {
            "n": 6,
            "edges": [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5)],
            "description": "–ü—Ä–æ—Å—Ç–µ –¥–µ—Ä–µ–≤–æ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—ó –±–∞–∑–æ–≤–∏—Ö –ø—Ä–∏–Ω—Ü–∏–ø—ñ–≤"
        },
        "–õ—ñ–Ω—ñ–π–Ω–µ –¥–µ—Ä–µ–≤–æ (5 –≤–µ—Ä—à–∏–Ω)": {
            "n": 5,
            "edges": [(0, 1), (1, 2), (2, 3), (3, 4)],
            "description": "–ù–∞–π–≥—ñ—Ä—à–∏–π –≤–∏–ø–∞–¥–æ–∫ - –¥–µ—Ä–µ–≤–æ —É –≤–∏–≥–ª—è–¥—ñ –ª–∞–Ω—Ü—é–≥–∞"
        },
        "–ó–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–µ –¥–µ—Ä–µ–≤–æ": {
            "n": 15,
            "edges": [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6), 
                     (3, 7), (3, 8), (4, 9), (4, 10), (5, 11), (5, 12), 
                     (6, 13), (6, 14)],
            "description": "–ü–æ–≤–Ω–µ –±—ñ–Ω–∞—Ä–Ω–µ –¥–µ—Ä–µ–≤–æ - –æ–ø—Ç–∏–º–∞–ª—å–Ω–∏–π –≤–∏–ø–∞–¥–æ–∫"
        },
        "–í–∏–ø–∞–¥–∫–æ–≤–µ —Ä–æ–∑–≥–∞–ª—É–∂–µ–Ω–µ –¥–µ—Ä–µ–≤–æ (127 –≤–µ—Ä—à–∏–Ω)": {
            "n": n,
            "edges": edges,
            "description": "–í–µ–ª–∏–∫–µ –¥–µ—Ä–µ–≤–æ –¥–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"
        }
    }

# ---------------------- –ì–æ–ª–æ–≤–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º ----------------------

class LCAFinder:
    def __init__(self, n, edges):
        self.n = n
        self.edges = edges
        self.tree = [[] for _ in range(n)]
        self.LOG = math.ceil(math.log2(n)) + 1 if n > 1 else 1
        self.depth = [0] * n
        self.parent = [0] * n
        self.parents = [[0] * self.LOG for _ in range(n)]
        self.visited = [False] * n
        self.paused = False
        self.stop_execution = False
        
        print(f"{Colors.OKCYAN}üîß –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–∏—Ö...{Colors.ENDC}")
        self.build_tree()
        self.dfs(0, 0)
        self.preprocess()
        print(f"{Colors.OKGREEN}‚úÖ –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!{Colors.ENDC}")

    def build_tree(self):
        for u, v in self.edges:
            self.tree[u].append(v)
            self.tree[v].append(u)

    def dfs(self, v, p):
        self.parent[v] = p
        self.visited[v] = True
        for u in self.tree[v]:
            if not self.visited[u]:
                self.depth[u] = self.depth[v] + 1
                self.dfs(u, v)

    def preprocess(self):
        print(f"{Colors.OKCYAN}üìä –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—ñ binary lifting...{Colors.ENDC}")
        for v in range(self.n):
            self.parents[v][0] = self.parent[v]
        for i in range(1, self.LOG):
            for v in range(self.n):
                self.parents[v][i] = self.parents[self.parents[v][i - 1]][i - 1]

    def wait_for_step(self, mode, delay):
        if self.stop_execution:
            return False
            
        if mode == "manual":
            response = input(f"{Colors.WARNING}–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å Enter –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –∫—Ä–æ–∫—É (–∞–±–æ 'q' –¥–ª—è –≤–∏—Ö–æ–¥—É): {Colors.ENDC}")
            if response.strip().lower() == 'q':
                self.stop_execution = True
                return False
        elif mode == "auto":
            start_time = time.time()
            while time.time() - start_time < delay:
                if self.stop_execution:
                    return False
                time.sleep(0.1)
        return True

    def lca(self, v, u, mode="manual", delay=1.0):
        self.stop_execution = False
        original_v, original_u = v, u
        
        print(f"\n{Colors.BOLD}{Colors.HEADER}üîç –ü–û–ß–ê–¢–û–ö –ó–ê–ü–ò–¢–£ LCA({original_v}, {original_u}){Colors.ENDC}")
        print(f"{Colors.OKCYAN}–ü–æ—Ç–æ—á–Ω—ñ –≤–µ—Ä—à–∏–Ω–∏: v={v} (–≥–ª–∏–±–∏–Ω–∞ {self.depth[v]}), u={u} (–≥–ª–∏–±–∏–Ω–∞ {self.depth[u]}){Colors.ENDC}")
        
        if not self.wait_for_step(mode, delay):
            return None

        # –ï—Ç–∞–ø 1: –í–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è –≥–ª–∏–±–∏–Ω
        if self.depth[v] > self.depth[u]:
            v, u = u, v
            print(f"{Colors.WARNING}üîÑ –ú—ñ–Ω—è—î–º–æ –º—ñ—Å—Ü—è–º–∏: —Ç–µ–ø–µ—Ä v={v}, u={u}{Colors.ENDC}")
            if not self.wait_for_step(mode, delay):
                return None

        print(f"\n{Colors.BOLD}üìè –ï–¢–ê–ü 1: –í–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è –≥–ª–∏–±–∏–Ω{Colors.ENDC}")
        print(f"–†—ñ–∑–Ω–∏—Ü—è –≥–ª–∏–±–∏–Ω: {self.depth[u]} - {self.depth[v]} = {self.depth[u] - self.depth[v]}")
        
        diff = self.depth[u] - self.depth[v]
        step = 0
        for k in reversed(range(self.LOG)):
            if diff >= (1 << k):
                print(f"{Colors.OKGREEN}  –ö—Ä–æ–∫ {step + 1}: –ü—ñ–¥–Ω—ñ–º–∞—î–º–æ u –∑ {u} –Ω–∞ 2^{k} = {1 << k} –∫—Ä–æ–∫—ñ–≤ ‚Üí {self.parents[u][k]}{Colors.ENDC}")
                u = self.parents[u][k]
                diff -= (1 << k)
                step += 1
                if not self.wait_for_step(mode, delay):
                    return None

        print(f"{Colors.OKBLUE}‚úÖ –ì–ª–∏–±–∏–Ω–∏ –≤–∏—Ä—ñ–≤–Ω—è–Ω—ñ: v={v}, u={u} (–æ–±–∏–¥–≤–∞ –Ω–∞ –≥–ª–∏–±–∏–Ω—ñ {self.depth[v]}){Colors.ENDC}")
        if not self.wait_for_step(mode, delay):
            return None

        if v == u:
            print(f"{Colors.OKGREEN}üéØ –í–µ—Ä—à–∏–Ω–∏ —Å–ø—ñ–≤–ø–∞–ª–∏! LCA({original_v}, {original_u}) = {v}{Colors.ENDC}")
            return v

        print(f"\n{Colors.BOLD}‚¨ÜÔ∏è  –ï–¢–ê–ü 2: –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–π –ø—ñ–¥–π–æ–º –¥–æ LCA{Colors.ENDC}")
        step = 0
        for k in reversed(range(self.LOG)):
            if self.parents[v][k] != self.parents[u][k]:
                print(f"{Colors.OKGREEN}  –ö—Ä–æ–∫ {step + 1}: –ü—ñ–¥–Ω—ñ–º–∞—î–º–æ –Ω–∞ 2^{k} = {1 << k} –∫—Ä–æ–∫—ñ–≤{Colors.ENDC}")
                print(f"    v: {v} ‚Üí {self.parents[v][k]}")
                print(f"    u: {u} ‚Üí {self.parents[u][k]}")
                v = self.parents[v][k]
                u = self.parents[u][k]
                step += 1
                if not self.wait_for_step(mode, delay):
                    return None

        result = self.parent[v]
        print(f"\n{Colors.BOLD}{Colors.OKGREEN}üéØ –†–ï–ó–£–õ–¨–¢–ê–¢: LCA({original_v}, {original_u}) = {result}{Colors.ENDC}")
        print(f"{Colors.OKCYAN}–§—ñ–Ω–∞–ª—å–Ω—ñ –ø–æ–∑–∏—Ü—ñ—ó: v={v}, u={u}, —ó—Ö –±–∞—Ç—å–∫–æ={result}{Colors.ENDC}")
        
        return result

# ---------------------- –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–µ—Ä–µ–≤–∞ ----------------------

def print_tree_ascii(tree, root=0, highlight_nodes=None):
    if highlight_nodes is None:
        highlight_nodes = set()
    
    def dfs(v, prefix, is_last, parent_v):
        node_str = str(v)
        if v in highlight_nodes:
            node_str = f"{Colors.OKGREEN}{Colors.BOLD}{node_str}{Colors.ENDC}"
        
        print(prefix + ("‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ ") + node_str)
        children = [u for u in tree[v] if u != parent_v]
        children.sort() 
        for i, u in enumerate(children):
            dfs(u, prefix + ("    " if is_last else "‚îÇ   "), i == len(children) - 1, v)

    n = len(tree)
    parent = [-1] * n

    def build_parents(v, p):
        parent[v] = p
        for u in tree[v]:
            if u != p:
                build_parents(u, v)

    build_parents(root, -1)
    print(f"\n{Colors.OKBLUE}{Colors.BOLD}üå≥ –°–¢–†–£–ö–¢–£–†–ê –î–ï–†–ï–í–ê:{Colors.ENDC}")
    dfs(root, "", True, -1)

def show_tree_info(finder):
    print(f"\n{Colors.OKCYAN}üìä –Ü–ù–§–û–†–ú–ê–¶–Ü–Ø –ü–†–û –î–ï–†–ï–í–û:{Colors.ENDC}")
    print(f"  ‚Ä¢ –ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–µ—Ä—à–∏–Ω: {finder.n}")
    print(f"  ‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –≥–ª–∏–±–∏–Ω–∞: {max(finder.depth)}")
    print(f"  ‚Ä¢ –†–æ–∑–º—ñ—Ä —Ç–∞–±–ª–∏—Ü—ñ binary lifting: {finder.LOG}")
    print(f"  ‚Ä¢ –ö–æ—Ä—ñ–Ω—å –¥–µ—Ä–µ–≤–∞: 0")

# ---------------------- –ú–µ–Ω—é ----------------------

def choose_execution_mode():
    print(f"\n{Colors.HEADER}üéÆ –û–ë–ï–†–Ü–¢–¨ –†–ï–ñ–ò–ú –í–ò–ö–û–ù–ê–ù–ù–Ø:{Colors.ENDC}")
    print(f"  1. {Colors.OKGREEN}–†—É—á–Ω–∏–π —Ä–µ–∂–∏–º{Colors.ENDC} - –ø–æ–∫—Ä–æ–∫–æ–≤–æ –∑ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—è–º Enter")
    print(f"  2. {Colors.OKBLUE}–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–µ–∂–∏–º{Colors.ENDC} - –∑ –∑–∞–¥–∞–Ω–æ—é —à–≤–∏–¥–∫—ñ—Å—Ç—é")
    
    while True:
        try:
            choice = int(input("–í–∞—à –≤–∏–±—ñ—Ä (1-2): "))
            if choice == 1:
                return "manual", 0
            elif choice == 2:
                while True:
                    try:
                        delay = float(input("–í–≤–µ–¥—ñ—Ç—å –∑–∞—Ç—Ä–∏–º–∫—É –º—ñ–∂ –∫—Ä–æ–∫–∞–º–∏ (—Å–µ–∫—É–Ω–¥–∏, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥ 1.5): "))
                        if delay >= 0:
                            return "auto", delay
                        else:
                            print("–ó–∞—Ç—Ä–∏–º–∫–∞ –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –Ω–µ –º–µ–Ω—à–µ 0")
                    except ValueError:
                        print("–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ")
            else:
                print("–û–±–µ—Ä—ñ—Ç—å 1 –∞–±–æ 2")
        except ValueError:
            print("–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ")

def main():
    clear_screen()
    print(f"{Colors.HEADER}{Colors.BOLD}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}‚ïë     –í–Ü–ó–£–ê–õ–Ü–ó–ê–¢–û–† –ê–õ–ì–û–†–ò–¢–ú–£ LCA (Binary Lifting)          ‚ïë{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù{Colors.ENDC}")
    
    examples = get_demo_examples()

    while True:
        print(f"\n{Colors.HEADER}{Colors.BOLD}üìã –ì–û–õ–û–í–ù–ï –ú–ï–ù–Æ:{Colors.ENDC}")
        print(f"  1. {Colors.OKCYAN}–û–ø–∏—Å –∞–ª–≥–æ—Ä–∏—Ç–º—É{Colors.ENDC}")
        print(f"  2. {Colors.OKCYAN}–û–ø–∏—Å —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É{Colors.ENDC}")
        
        for i, name in enumerate(examples):
            print(f"  {i + 3}. {Colors.OKGREEN}{name}{Colors.ENDC}")
        
        print(f"  {len(examples) + 3}. {Colors.WARNING}–°—Ç–≤–æ—Ä–∏—Ç–∏ –≤–ª–∞—Å–Ω–µ –¥–µ—Ä–µ–≤–æ{Colors.ENDC}")
        print(f"  0. {Colors.FAIL}–í–∏–π—Ç–∏{Colors.ENDC}")

        try:
            choice = int(input(f"\n{Colors.BOLD}–í–∞—à –≤–∏–±—ñ—Ä: {Colors.ENDC}"))
        except ValueError:
            print(f"{Colors.FAIL}–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ!{Colors.ENDC}")
            continue

        if choice == 0:
            print(f"{Colors.OKCYAN}–î–æ –ø–æ–±–∞—á–µ–Ω–Ω—è! üëã{Colors.ENDC}")
            break
        elif choice == 1:
            clear_screen()
            print_algorithm_description()
            clear_screen()
            continue
        elif choice == 2:
            clear_screen()
            print_interface_description()
            clear_screen()
            continue
        elif 3 <= choice <= len(examples) + 2:
            name = list(examples)[choice - 3]
            data = examples[name]
            print(f"\n{Colors.OKBLUE}üìù –û–ø–∏—Å: {data['description']}{Colors.ENDC}")
        elif choice == len(examples) + 3:
            try:
                n = int(input("–ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–µ—Ä—à–∏–Ω: "))
                if n <= 0:
                    print(f"{Colors.FAIL}–ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–µ—Ä—à–∏–Ω –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –±—ñ–ª—å—à–µ 0{Colors.ENDC}")
                    continue
                    
                m = n - 1
                edges = []
                print(f"–í–≤–µ–¥—ñ—Ç—å {m} —Ä–µ–±–µ—Ä —É —Ñ–æ—Ä–º–∞—Ç—ñ 'u v' (–≤–µ—Ä—à–∏–Ω–∏ –≤—ñ–¥ 0 –¥–æ {n-1}):")
                
                for i in range(m):
                    while True:
                        try:
                            u, v = map(int, input(f"–†–µ–±—Ä–æ {i+1}: ").split())
                            if 0 <= u < n and 0 <= v < n:
                                edges.append((u, v))
                                break
                            else:
                                print(f"–í–µ—Ä—à–∏–Ω–∏ –ø–æ–≤–∏–Ω–Ω—ñ –±—É—Ç–∏ –≤—ñ–¥ 0 –¥–æ {n-1}")
                        except ValueError:
                            print("–í–≤–µ–¥—ñ—Ç—å –¥–≤–∞ —á–∏—Å–ª–∞ —á–µ—Ä–µ–∑ –ø—Ä–æ–±—ñ–ª")
                
                data = {"n": n, "edges": edges, "description": "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—Ü—å–∫–µ –¥–µ—Ä–µ–≤–æ"}
            except ValueError:
                print(f"{Colors.FAIL}–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ!{Colors.ENDC}")
                continue
        else:
            print(f"{Colors.FAIL}–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –≤–∏–±—ñ—Ä!{Colors.ENDC}")
            continue

        try:
            finder = LCAFinder(data["n"], data["edges"])
            print_tree_ascii(finder.tree, root=0)
            show_tree_info(finder)

            while True:
                print(f"\n{Colors.HEADER}üîç –ó–ê–ü–ò–¢–ò LCA:{Colors.ENDC}")
                query = input("–í–≤–µ–¥—ñ—Ç—å –¥–≤—ñ –≤–µ—Ä—à–∏–Ω–∏ –¥–ª—è LCA (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: 3 5) –∞–±–æ 'back' –¥–ª—è –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è: ").strip()
                
                if query.lower() == 'back':
                    break
                    
                try:
                    v, u = map(int, query.split())
                    if not (0 <= v < data["n"]) or not (0 <= u < data["n"]):
                        print(f"{Colors.FAIL}–î–æ–ø—É—Å—Ç–∏–º—ñ —ñ–Ω–¥–µ–∫—Å–∏ –≤–µ—Ä—à–∏–Ω: –≤—ñ–¥ 0 –¥–æ {data['n'] - 1}{Colors.ENDC}")
                        continue
                except ValueError:
                    print(f"{Colors.FAIL}–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–∫–ª–∞–¥: 3 4{Colors.ENDC}")
                    continue

                mode, delay = choose_execution_mode()
                
                print(f"\n{Colors.OKCYAN}–†–µ–∂–∏–º: {'–†—É—á–Ω–∏–π' if mode == 'manual' else f'–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π ({delay}s)'}{Colors.ENDC}")
                if mode == "auto":
                    print(f"{Colors.WARNING}–ü—ñ–¥–∫–∞–∑–∫–∞: –≤–≤–µ–¥—ñ—Ç—å 'p' —â–æ–± –ø—Ä–∏–∑—É–ø–∏–Ω–∏—Ç–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è{Colors.ENDC}")
                
                result = finder.lca(v, u, mode, delay)
                if result is not None:
                    input(f"\n{Colors.OKGREEN}–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å Enter –¥–ª—è –ø—Ä–æ–¥–æ–≤–∂–µ–Ω–Ω—è...{Colors.ENDC}")

        except Exception as e:
            print(f"{Colors.FAIL}–ü–æ–º–∏–ª–∫–∞: {e}{Colors.ENDC}")
            print(f"{Colors.WARNING}–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ—Å—Ç—å –≤–≤–µ–¥–µ–Ω–∏—Ö –¥–∞–Ω–∏—Ö{Colors.ENDC}")


if __name__ == '__main__':
    main()
